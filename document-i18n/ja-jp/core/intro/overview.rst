概要
--------

.. index:: concepts, value, instruction, trap, function, table, memory, linear memory, module, ! embedder, integer, floating-point, IEEE 754, Boolean, two's complement
.. _concepts:

概念
~~~~~~~~

WebAssemblyは、低レベルのアセンブラ的なプログラミング言語をエンコードします。
この言語は、以下の概念の周辺に構築されています。

.. _value:

**値（value）**
  WebAssemblyでは4つの「値型（value type）」だけを定義します。それらは「整数（integer）」と「|IEEE754|_ 数値」で、それぞれにビット幅が32ビットのものと64ビットのものがあります。
  32ビット整数はブーリアンやメモリアドレスとしても利用されます。
  これらの型に対しては、完全な行列同士の変換を含む通常の操作が可能です。
  符号付き整数と符号なし整数は区別されません。
  その代わり、整数は演算の種類によって解釈され、2の補数表現の符号なしまたは符号付きのいずれかで指定されます。

.. _instruction:

**インストラクション（instruction）**
  WebAssemblyの計算モデルは「スタックマシン」に基づいています。
  コードは、実行順に並んだ「インストラクション」の集まり（シーケンス）からなっています。
  インストラクションは暗黙の「オペランドスタック [#stackmachine]_ 」上にある値を操作します。インストラクションは主に以下の2つのカテゴリに分かれます。
  「*シンプル* インストラクション」はデータに対する基本的な操作を実行するもので、オペランドスタックから引数をpopし、結果をpushして戻します。
  「*制御* （control）インストラクション」は制御フローを変えます。制御フローは「構造化」されます。すなわち「ブロック」「ループ」「条件」などは、十分にネストされた形の構成体（construct）によって表現されます。分岐（branch）のジャンプ先にできるはこうした構成体だけです。

.. _trap:

**トラップ（trap）**
  一部の条件下においては、特定のインストラクションで「トラップ」が発生することがあります。
  トラップが発生すると、実行は直ちに中断（abort）します。
  トラップはWebAssemblyコードでは扱えないようになっている代わりに外部環境に出力されるようになっており、通常はそこでトラップをキャッチします。

.. _function:

**関数（function）**
  コードは、個別の「関数」によって編成されます。
  個別の関数は、一連の値をパラメータとして受け取り、一連の値を結果として返します [#arity]_ 。
  関数同士は（再帰を含めて）お互いを呼び出せるようになっており、その結果は、直接アクセスできない暗黙のコールスタックに置かれます。
  関数は、仮想レジスタとしても使えるミュータブル（改変可能）な「ローカル変数」も宣言できます。

.. _table:

**テーブル（table）**
  「テーブル」は、特定の「要素型（element type）」の不透明な値の配列です。
  プログラムはテーブルを用いて、動的なインデックスオペランドを介して間接的にそれらの値を選択できます。
  現時点で利用可能な要素型は「型なし関数参照（untyped function reference）」のみです。
  これによって、プログラムはテーブルへの動的なインデックスを介して間接的に関数を呼び出せます。
  たとえば、テーブルインデックスを介することで関数ポインタをエミュレートできます。

.. _memory:

**線形メモリー（linear memory）**
  線形メモリーとは、連続かつミュータブルなrawバイト配列です。
  このようなメモリーは初期サイズを指定して作成できますが、動的に成長させることもできます。
  プログラムは、線形メモリー上の任意のバイトアドレス（アラインされていないものも含む）に対して値を読み書きできます。
  整数の読み書きでは「ストレージサイズ」を指摘でき、これは個別の値型のサイズよりも小さいサイズになります。
  現在のメモリサイズの境界を超えてアクセスするとトラップが発生します。

.. _module:

**モジュール（module）**
  WebAssemblyバイナリは「モジュール」形式を取ります。
  モジュールには「関数」「テーブル」「線形メモリー」の定義が含まれるほかに、ミュータブルまたはイミュータブル（改変不能）な「グローバル変数」も含まれます。
  モジュールの定義は「インポート」も可能で、「モジュール名と名前のペア」と「適切な型」を指定できます。
  個別のモジュール定義は、複数の名前で「エクスポート」することも可能です。
  モジュールではこうした定義の他に、モジュールのメモリーやテーブルを初期化するデータも定義できます。初期化データは、指定のオフセットにコピーされる「セグメント」の形を取ります。
  モジュールでは、自動的に実行される「開始関数（start function）」も定義できます。

.. _embedder:

**エンベダー（embedder）**
  WebAssemblyは、ホスト環境に「埋め込まれる」のが典型的な実装です。
  この環境は、「モジュールの初期化方法」「インポートの提供方法（ホスト側での定義も含む）」「エクスポートにアクセスする方法」を定義します。
  ただし、個別の埋め込みの詳細については本仕様書の範疇を超えるので、環境固有のAPI定義で補足します。

.. [#stackmachine] 実用上は、実際のオペランドスタックを実装で維持する必要はありません。その代わりこのスタックは、インストラクションから暗黙に参照される「無名レジスタ（anonymous register）」のセットとして表示可能です。 :ref:`型システム <validation>` は、スタックの深さ、ひいては参照されるすべてのレジスタが静的に認識されることを保証します。

.. [#arity] WebAssemblyの現在のバージョンでは、結果の値は最大でもひとつまでとなる可能性があります。

.. index:: phases, decoding, validation, execution, instantiation, invocation

セマンティクス上のフェーズ
~~~~~~~~~~~~~~~

WebAssemblyのセマンティクス（意味論: semantics）は、概念上3つのフェーズに分かれています。
仕様では、言語の個別の部分について以下が指定されています。

.. _decoding:

**デコード（decoding）**
  WebAssemblyのモジュールは、1つの「バイナリフォーマット」内に分散します。
  「デコード」では、そのフォーマットをモジュールの内部表現形式に変換します。
  本仕様書では、この表現形式を「抽象構文（abstract syntax）」でモデリングしますが、実際の実装ではマシンコードに直接コンパイルされる可能性があります。

.. _validation:

**検証（validation）**
  デコードされたモジュールは「有効（valid）」でなければなりません。
  検証では、モジュールが意味を持ち、かつ安全であることを保証するために多数の「整形式（well-formedness）」条件をチェックします。
  特に本体内の関数やインストラクションシーケンスに対して「型チェック（type checking）」を実行することで、オペランドスタックが一貫した形で利用されていることなどを保証します。

.. _execution:
.. _instantiation:
.. _invocation:

**実行（execution）**
  最後に、有効なモジュールを「実行」できます。
  実行はさらに以下の2つのフェーズに分かれます。

  **インスタンス化（instantiation）**:
  モジュールの「インスタンス」は、モジュールの動的な表現であり、インスタンス自身のステートと実行スタックを完備しています。
  インスタンス化では、すべてのインポートに対する定義を与えられたモジュール本体自体を実行します。
  インスタンス化ではグローバルな値やメモリーやテーブルを初期化し、モジュールに開始関数が定義されていればそれも実行します。
  インスタンス化では、モジュールのエクスポートのインスタンスを返します。

  **呼び出し（invocation）**:
  インスタンス化が完了すると、モジュールインスタンス上でエクスポートされた関数を「呼び出す」ことで、さらにWebAssembly計算（computation）を初期化できます。
  必要な引数をそれぞれの関数に渡すことで、関数が実行されて結果を返します。

  インスタンス化と呼び出しは、埋め込み環境内での操作です。

